package main

import (
    "encoding/json"
    "log/slog"
    "net/http"
    "os"

    "github.com/go-chi/chi/v5"
    "github.com/yosupo06/library-checker-judge/database"
    restapi "github.com/yosupo06/library-checker-judge/restapi/internal/api"
    "gorm.io/gorm"
)

func getEnv(key, def string) string {
	if v := os.Getenv(key); v != "" {
		return v
	}
	return def
}

type server struct{ db *gorm.DB }

// GetRanking handles GET /ranking (generated by oapi-codegen)
func (s *server) GetRanking(w http.ResponseWriter, r *http.Request, params restapi.GetRankingParams) {
	skip := 0
	limit := 100
	if params.Skip != nil {
		skip = int(*params.Skip)
	}
	if params.Limit != nil {
		limit = int(*params.Limit)
	}
	if limit > 1000 {
		http.Error(w, "limit must not be greater than 1000", http.StatusBadRequest)
		return
	}
	results, total, err := database.FetchRanking(s.db, skip, limit)
	if err != nil {
		http.Error(w, "failed to fetch ranking", http.StatusInternalServerError)
		return
	}
	stats := make([]restapi.UserStatistics, 0, len(results))
	for _, rs := range results {
		stats = append(stats, restapi.UserStatistics{Name: rs.UserName, Count: int32(rs.AcCount)})
	}
    resp := restapi.RankingResponse{Statistics: stats, Count: int32(total)}
    w.Header().Set("Content-Type", "application/json")
    _ = json.NewEncoder(w).Encode(resp)
}

func main() {
    db := database.Connect(database.GetDSNFromEnv(), getEnv("API_DB_LOG", "") != "")

    r := chi.NewRouter()
	// CORS (dev)
	r.Use(func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
			w.Header().Set("Access-Control-Allow-Origin", "*")
			w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS")
			w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
			if req.Method == http.MethodOptions {
				w.WriteHeader(http.StatusNoContent)
				return
			}
			next.ServeHTTP(w, req)
		})
	})

    // Register OpenAPI handlers on chi router
    _ = restapi.HandlerFromMux(&server{db: db}, r)
    r.Get("/openapi.yaml", func(w http.ResponseWriter, req *http.Request) { http.ServeFile(w, req, "openapi/openapi.yaml") })
    r.Get("/health", func(w http.ResponseWriter, req *http.Request) { _, _ = w.Write([]byte("SERVING")) })

	port := getEnv("PORT", "12381")
	slog.Info("Launch REST server", "port", port)
	if err := http.ListenAndServe(":"+port, r); err != nil {
		slog.Error("server exit", "error", err)
		os.Exit(1)
	}
}
