package main

import (
	"encoding/json"
	"log/slog"
	"net/http"
	"os"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/yosupo06/library-checker-judge/database"
	"github.com/yosupo06/library-checker-judge/langs"
	restapi "github.com/yosupo06/library-checker-judge/restapi/internal/api"
	"gorm.io/gorm"
)

func getEnv(key, def string) string {
	if v := os.Getenv(key); v != "" {
		return v
	}
	return def
}

type server struct{ db *gorm.DB }

// GetRanking handles GET /ranking (generated by oapi-codegen)
func (s *server) GetRanking(w http.ResponseWriter, r *http.Request, params restapi.GetRankingParams) {
	skip := 0
	limit := 100
	if params.Skip != nil {
		skip = int(*params.Skip)
	}
	if params.Limit != nil {
		limit = int(*params.Limit)
	}
	if limit > 1000 {
		http.Error(w, "limit must not be greater than 1000", http.StatusBadRequest)
		return
	}
	results, total, err := database.FetchRanking(s.db, skip, limit)
	if err != nil {
		http.Error(w, "failed to fetch ranking", http.StatusInternalServerError)
		return
	}
	stats := make([]restapi.UserStatistics, 0, len(results))
	for _, rs := range results {
		stats = append(stats, restapi.UserStatistics{Name: rs.UserName, Count: int32(rs.AcCount)})
	}
	resp := restapi.RankingResponse{Statistics: stats, Count: int32(total)}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)
}

// GetProblems handles GET /problems
func (s *server) GetProblems(w http.ResponseWriter, r *http.Request) {
	rows, err := database.FetchProblemList(s.db)
	if err != nil {
		http.Error(w, "failed to fetch problems", http.StatusInternalServerError)
		return
	}
	problems := make([]restapi.Problem, 0, len(rows))
	for _, p := range rows {
		problems = append(problems, restapi.Problem{Name: p.Name, Title: p.Title})
	}
	resp := restapi.ProblemListResponse{Problems: problems}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)
}

// GetProblemInfo handles GET /problems/{name}
func (s *server) GetProblemInfo(w http.ResponseWriter, r *http.Request, name string) {
	if name == "" {
		http.Error(w, "missing problem name", http.StatusBadRequest)
		return
	}
	p, err := database.FetchProblem(s.db, name)
	if err != nil {
		if err == database.ErrNotExist {
			http.Error(w, "problem not found", http.StatusNotFound)
			return
		}
		http.Error(w, "failed to fetch problem", http.StatusInternalServerError)
		return
	}
	resp := restapi.ProblemInfoResponse{
		Title:            p.Title,
		SourceUrl:        p.SourceUrl,
		TimeLimit:        float32(p.Timelimit) / 1000.0,
		Version:          p.Version,
		TestcasesVersion: p.TestCasesVersion,
		OverallVersion:   p.OverallVersion,
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)
}

// GetLangList handles GET /langs
func (s *server) GetLangList(w http.ResponseWriter, r *http.Request) {
	var ls []restapi.Lang
	for _, l := range langs.LANGS {
		ls = append(ls, restapi.Lang{Id: l.ID, Name: l.Name, Version: l.Version})
	}
	resp := restapi.LangListResponse{Langs: ls}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)
}

// GetProblemCategories handles GET /categories
func (s *server) GetProblemCategories(w http.ResponseWriter, r *http.Request) {
	cats, err := database.FetchProblemCategories(s.db)
	if err != nil {
		http.Error(w, "failed to fetch categories", http.StatusInternalServerError)
		return
	}
	result := make([]restapi.ProblemCategory, 0, len(cats))
	for _, c := range cats {
		result = append(result, restapi.ProblemCategory{Title: c.Title, Problems: c.Problems})
	}
	resp := restapi.ProblemCategoriesResponse{Categories: result}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)
}

// PostSubmit handles POST /submit
func (s *server) PostSubmit(w http.ResponseWriter, r *http.Request) {
	var req restapi.SubmitRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "invalid json", http.StatusBadRequest)
		return
	}
	if req.Problem == "" || req.Source == "" || req.Lang == "" {
		http.Error(w, "missing required fields", http.StatusBadRequest)
		return
	}
	// Validate problem exists
	if _, err := database.FetchProblem(s.db, req.Problem); err != nil {
		http.Error(w, "unknown problem", http.StatusBadRequest)
		return
	}
	// Validate language exists
	if _, ok := langs.GetLang(req.Lang); !ok {
		http.Error(w, "unknown language", http.StatusBadRequest)
		return
	}
	// Validate source size (<= 1MB)
	if len(req.Source) == 0 || len(req.Source) > 1024*1024 {
		http.Error(w, "invalid source length", http.StatusBadRequest)
		return
	}
	// Create anonymous submission (REST server has no auth yet)
	sub := database.Submission{
		SubmissionTime: time.Now(),
		ProblemName:    req.Problem,
		Lang:           req.Lang,
		Status:         "WJ",
		Source:         req.Source,
		MaxTime:        -1,
		MaxMemory:      -1,
	}
	id, err := database.SaveSubmission(s.db, sub)
	if err != nil {
		http.Error(w, "submit failed", http.StatusInternalServerError)
		return
	}
	tleKnockout := false
	if req.TleKnockout != nil {
		tleKnockout = *req.TleKnockout
	}
	if err := database.PushSubmissionTask(s.db, database.SubmissionData{ID: id, TleKnockout: tleKnockout}, 45); err != nil {
		http.Error(w, "enqueue failed", http.StatusInternalServerError)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(restapi.SubmitResponse{Id: id})
}

// GetSubmissionInfo handles GET /submissions/{id}
func (s *server) GetSubmissionInfo(w http.ResponseWriter, r *http.Request, id int32) {
	sub, err := database.FetchSubmission(s.db, id)
	if err != nil {
		if err == database.ErrNotExist {
			http.Error(w, "not found", http.StatusNotFound)
			return
		}
		http.Error(w, "failed to fetch submission", http.StatusInternalServerError)
		return
	}
	cases, err := database.FetchTestcaseResults(s.db, id)
	if err != nil {
		http.Error(w, "failed to fetch cases", http.StatusInternalServerError)
		return
	}
	// Build overview
	var userNamePtr *string
	if sub.UserName.Valid {
		v := sub.UserName.String
		userNamePtr = &v
	}
	overview := restapi.SubmissionOverview{
		Id:           sub.ID,
		ProblemName:  sub.Problem.Name,
		ProblemTitle: sub.Problem.Title,
		UserName:     userNamePtr,
		Lang:         sub.Lang,
		IsLatest:     sub.TestCasesVersion == sub.Problem.TestCasesVersion,
		Status:       sub.Status,
		Time:         float32(sub.MaxTime) / 1000.0,
		Memory:       sub.MaxMemory,
	}
	if !sub.SubmissionTime.IsZero() {
		t := sub.SubmissionTime
		overview.SubmissionTime = &t
	}
	// Build case results
	cr := make([]restapi.SubmissionCaseResult, 0, len(cases))
	for _, c := range cases {
		var stderr *[]byte
		if len(c.Stderr) > 0 {
			b := c.Stderr
			stderr = &b
		}
		var checker *[]byte
		if len(c.CheckerOut) > 0 {
			b := c.CheckerOut
			checker = &b
		}
		cr = append(cr, restapi.SubmissionCaseResult{
			Case:       c.Testcase,
			Status:     c.Status,
			Time:       float32(c.Time) / 1000.0,
			Memory:     c.Memory,
			Stderr:     stderr,
			CheckerOut: checker,
		})
	}
	var compileErr *[]byte
	if len(sub.CompileError) > 0 {
		b := sub.CompileError
		compileErr = &b
	}
	resp := restapi.SubmissionInfoResponse{
		Overview:     overview,
		Source:       sub.Source,
		CompileError: compileErr,
		CanRejudge:   false, // no auth in REST yet
	}
	if len(cr) > 0 {
		resp.CaseResults = &cr
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)
}

// GetSubmissionList handles GET /submissions
func (s *server) GetSubmissionList(w http.ResponseWriter, r *http.Request, params restapi.GetSubmissionListParams) {
	// Defaults
	skip := 0
	limit := 100
	if params.Skip != nil {
		skip = int(*params.Skip)
	}
	if params.Limit != nil {
		limit = int(*params.Limit)
	}
	if limit > 1000 {
		http.Error(w, "limit must not be greater than 1000", http.StatusBadRequest)
		return
	}
	order := ""
	if params.Order != nil {
		order = *params.Order
	}
	var dbOrder []database.SubmissionOrder
	switch order {
	case "", "-id":
		dbOrder = []database.SubmissionOrder{database.ID_DESC}
	case "+time":
		dbOrder = []database.SubmissionOrder{database.MAX_TIME_ASC, database.ID_DESC}
	default:
		http.Error(w, "unknown sort order", http.StatusBadRequest)
		return
	}
	problem := deref(params.Problem)
	status := deref(params.Status)
	lang := deref(params.Lang)
	user := deref(params.User)
	dedup := false
	if params.DedupUser != nil {
		dedup = *params.DedupUser
	}
	list, count, err := database.FetchSubmissionList(s.db, problem, status, lang, user, dedup, dbOrder, skip, limit)
	if err != nil {
		http.Error(w, "failed to fetch submissions", http.StatusInternalServerError)
		return
	}
	overviews := make([]restapi.SubmissionOverview, 0, len(list))
	for _, sub := range list {
		var userNamePtr *string
		if sub.UserName.Valid {
			v := sub.UserName.String
			userNamePtr = &v
		}
		ov := restapi.SubmissionOverview{
			Id:           sub.ID,
			ProblemName:  sub.Problem.Name,
			ProblemTitle: sub.Problem.Title,
			UserName:     userNamePtr,
			Lang:         sub.Lang,
			IsLatest:     sub.TestCasesVersion == sub.Problem.TestCasesVersion,
			Status:       sub.Status,
			Time:         float32(sub.MaxTime) / 1000.0,
			Memory:       sub.MaxMemory,
		}
		if !sub.SubmissionTime.IsZero() {
			t := sub.SubmissionTime
			ov.SubmissionTime = &t
		}
		overviews = append(overviews, ov)
	}
	resp := restapi.SubmissionListResponse{Submissions: overviews, Count: int32(count)}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)
}

func deref[T any](p *T) T {
	var zero T
	if p == nil {
		return zero
	}
	return *p
}

func main() {
	db := database.Connect(database.GetDSNFromEnv(), getEnv("API_DB_LOG", "") != "")

	r := chi.NewRouter()
	// CORS (dev)
	r.Use(func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
			w.Header().Set("Access-Control-Allow-Origin", "*")
			w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
			w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
			if req.Method == http.MethodOptions {
				w.WriteHeader(http.StatusNoContent)
				return
			}
			next.ServeHTTP(w, req)
		})
	})

	// Register OpenAPI handlers on chi router
	_ = restapi.HandlerFromMux(&server{db: db}, r)
	r.Get("/openapi.yaml", func(w http.ResponseWriter, req *http.Request) { http.ServeFile(w, req, "openapi/openapi.yaml") })
	r.Get("/health", func(w http.ResponseWriter, req *http.Request) { _, _ = w.Write([]byte("SERVING")) })

	port := getEnv("PORT", "12381")
	slog.Info("Launch REST server", "port", port)
	if err := http.ListenAndServe(":"+port, r); err != nil {
		slog.Error("server exit", "error", err)
		os.Exit(1)
	}
}
