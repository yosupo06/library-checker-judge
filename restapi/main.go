package main

import (
	"encoding/json"
	"log/slog"
	"net/http"
	"os"

	"github.com/go-chi/chi/v5"
	"github.com/yosupo06/library-checker-judge/database"
	"github.com/yosupo06/library-checker-judge/langs"
	restapi "github.com/yosupo06/library-checker-judge/restapi/internal/api"
	"gorm.io/gorm"
)

func getEnv(key, def string) string {
	if v := os.Getenv(key); v != "" {
		return v
	}
	return def
}

type server struct{ db *gorm.DB }

// GetRanking handles GET /ranking (generated by oapi-codegen)
func (s *server) GetRanking(w http.ResponseWriter, r *http.Request, params restapi.GetRankingParams) {
	skip := 0
	limit := 100
	if params.Skip != nil {
		skip = int(*params.Skip)
	}
	if params.Limit != nil {
		limit = int(*params.Limit)
	}
	if limit > 1000 {
		http.Error(w, "limit must not be greater than 1000", http.StatusBadRequest)
		return
	}
	results, total, err := database.FetchRanking(s.db, skip, limit)
	if err != nil {
		http.Error(w, "failed to fetch ranking", http.StatusInternalServerError)
		return
	}
	stats := make([]restapi.UserStatistics, 0, len(results))
	for _, rs := range results {
		stats = append(stats, restapi.UserStatistics{Name: rs.UserName, Count: int32(rs.AcCount)})
	}
	resp := restapi.RankingResponse{Statistics: stats, Count: int32(total)}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)
}

// GetProblems handles GET /problems
func (s *server) GetProblems(w http.ResponseWriter, r *http.Request) {
	rows, err := database.FetchProblemList(s.db)
	if err != nil {
		http.Error(w, "failed to fetch problems", http.StatusInternalServerError)
		return
	}
	problems := make([]restapi.Problem, 0, len(rows))
	for _, p := range rows {
		problems = append(problems, restapi.Problem{Name: p.Name, Title: p.Title})
	}
	resp := restapi.ProblemListResponse{Problems: problems}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)
}

// GetProblemInfo handles GET /problems/{name}
func (s *server) GetProblemInfo(w http.ResponseWriter, r *http.Request, name string) {
	if name == "" {
		http.Error(w, "missing problem name", http.StatusBadRequest)
		return
	}
	p, err := database.FetchProblem(s.db, name)
	if err != nil {
		if err == database.ErrNotExist {
			http.Error(w, "problem not found", http.StatusNotFound)
			return
		}
		http.Error(w, "failed to fetch problem", http.StatusInternalServerError)
		return
	}
	resp := restapi.ProblemInfoResponse{
		Title:            p.Title,
		SourceUrl:        p.SourceUrl,
		TimeLimit:        float32(p.Timelimit) / 1000.0,
		Version:          p.Version,
		TestcasesVersion: p.TestCasesVersion,
		OverallVersion:   p.OverallVersion,
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)
}

// GetLangList handles GET /langs
func (s *server) GetLangList(w http.ResponseWriter, r *http.Request) {
	var ls []restapi.Lang
	for _, l := range langs.LANGS {
		ls = append(ls, restapi.Lang{Id: l.ID, Name: l.Name, Version: l.Version})
	}
	resp := restapi.LangListResponse{Langs: ls}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)
}

// GetProblemCategories handles GET /categories
func (s *server) GetProblemCategories(w http.ResponseWriter, r *http.Request) {
	cats, err := database.FetchProblemCategories(s.db)
	if err != nil {
		http.Error(w, "failed to fetch categories", http.StatusInternalServerError)
		return
	}
	result := make([]restapi.ProblemCategory, 0, len(cats))
	for _, c := range cats {
		result = append(result, restapi.ProblemCategory{Title: c.Title, Problems: c.Problems})
	}
	resp := restapi.ProblemCategoriesResponse{Categories: result}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)
}

func main() {
	db := database.Connect(database.GetDSNFromEnv(), getEnv("API_DB_LOG", "") != "")

	r := chi.NewRouter()
	// CORS (dev)
	r.Use(func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
			w.Header().Set("Access-Control-Allow-Origin", "*")
			w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS")
			w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
			if req.Method == http.MethodOptions {
				w.WriteHeader(http.StatusNoContent)
				return
			}
			next.ServeHTTP(w, req)
		})
	})

	// Register OpenAPI handlers on chi router
	_ = restapi.HandlerFromMux(&server{db: db}, r)
	r.Get("/openapi.yaml", func(w http.ResponseWriter, req *http.Request) { http.ServeFile(w, req, "openapi/openapi.yaml") })
	r.Get("/health", func(w http.ResponseWriter, req *http.Request) { _, _ = w.Write([]byte("SERVING")) })

	port := getEnv("PORT", "12381")
	slog.Info("Launch REST server", "port", port)
	if err := http.ListenAndServe(":"+port, r); err != nil {
		slog.Error("server exit", "error", err)
		os.Exit(1)
	}
}
